#include <iostream>
using namespace std;

// ------------------------------------------------------
// 전역 배열: 최대 N=1000이므로, 1010 x 1010 정도면 충분
// A[i][j] = i행 j열 칸에 배치할 동전의 개수
// ------------------------------------------------------
static int A[1010][1010];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    long long N, K;
    cin >> N >> K;

    // --------------------------------------------------
    // 1) 흑백 칸 개수(또는 두 종류의 칸 개수) 계산
    //    - S1: 더 적은 쪽의 칸 개수
    //    - S2: 더 많은 쪽의 칸 개수
    //
    //   예를 들어 N*N이 짝수라면,
    //     S1 = S2 = (N*N)/2
    //   홀수라면,
    //     S1 = floor((N*N)/2)
    //     S2 = ceil((N*N)/2)
    // --------------------------------------------------
    //   체스판처럼 칠했을 때,
    //   "검은 칸" 개수 = (N*N)/2 (내림) 또는 (N*N)/2 + 1
    //   "흰 칸" 개수도 마찬가지로 쌍을 이룸.
    // --------------------------------------------------
    long long S1 = (N * N) / 2;              // 작은 파트(흑/백 중 하나)
    long long S2 = (N * N) / 2 + (N % 2 == 1); // 큰 파트 (N*N이 홀수일 경우 +1)

    // --------------------------------------------------
    // 2) 불가능한 경우 판별:
    //    S1 = 더 적은 칸에 동전을 1개씩 놓더라도,
    //    "최소"로 필요한 동전 개수는 S1개.
    //    이 최소조차 K보다 크다면 답이 없다.
    //    (왜냐하면 인접 차이를 1로 만들려면,
    //     결국 어떤 칸엔 동전을 0개 이상으로 놓아야 하는데
    //     '더 적은 칸' 쪽에 최소 1개씩은 넣어야 하는 방식으로
    //     설계된 로직)
    // --------------------------------------------------
    if (S1 > K) 
    {
        cout << -1 << "\n";

        return 0;
    }

    // --------------------------------------------------
    // 3) N=1인 극단 케이스: 인접 칸이 아예 없으므로
    //    그 한 칸에 전부 K개 넣으면 된다.
    // --------------------------------------------------
    if (N == 1)
    {
        cout << K << "\n";

        return 0;
    }

    // --------------------------------------------------
    // 4) 본격 로직
    //    - i를 돌면서, "i"와 "i+1"을 이용하여
    //      흑칸에는 i 또는 (i+1), 백칸에는 i 또는 (i+1)
    //      식으로 배치할 때, 총합이 K가 되는지 검사
    //
    //    - 구체적으론,
    //      now = S1*i + S2*(i+1)  일 때,
    //      현재 동전 합은 now 이고,
    //      만약 K가 더 크면 "남는 차이(K - now)"를
    //      일부 칸에 2개씩 더 넣어서 맞출 수 있는지 본다
    //      (각 칸 간 동전 차이가 1이 되려면,
    //       특정 색 칸에 2개씩 더 넣는 식으로 보정)
    //
    //    - toggle 플래그를 이용해,
    //      "첫 칸"을 (i+1)로 놓을지 i로 놓을지 결정
    // --------------------------------------------------
    int a = 0;    // 흑/백의 기본 배치값
    int remainder = 0;    // 나중에 2개씩 추가로 배치할 잔여 동전 수
    bool toggle = false;

    // i를 0부터 K까지 순회 (사실 큰 수까지 순회하지만 
    // 실제로는 빨리 break됨)
    for (int i = 0; i <= K; i++)
    {
        // ----------------------------------------------
        // (1) 흑칸 i, 백칸 (i+1) 식으로 배치할 경우
        //     now = S1*i + S2*(i+1)
        //     => 이미 배치된 동전 합 = now
        //     남은 동전 = K - now
        //     그런데 "차이를 1로 유지"하면서
        //     필요한 곳에 2개씩 더 배치 가능 (remainder이 2씩 줄어듦)
        // ----------------------------------------------
        long long now = S1 * i + S2 * (i + 1);
        remainder = (int)(K - now); // 남은 동전(추가로 2씩 더 넣을 수 있는 양)

        // 조건1) now <= K 이면서 K <= now + (S1 * 2)
        //   => 남은 동전을 2씩 배치하는데,
        //      "2를 넣을 칸"은 최대 S1개까지 가능(흑칸이 S1개라 가정)
        //      즉 remainder <= (2*S1)
        if (now <= K && K <= now + S1 * 2)
        {
            // 조건2) 남은 동전이 짝수여야 (2씩 넣을 수 있다)
            if ((K - now) % 2 == 0)
            {
                a = i; // 흑칸에 i개, 백칸에 (i+1)개 기본 세팅

                break;
            }
        }

        // ----------------------------------------------
        // (2) 흑칸 (i+1), 백칸 i 식으로 배치할 경우
        //     now = S1*(i+1) + S2*i
        // ----------------------------------------------
        now = S1 * (i + 1) + S2 * i;
        remainder = (int)(K - now);

        // 남은 동전이 2씩 배치 가능한지 확인 (이번엔 "백칸"이 S2개)
        if (now <= K && K <= now + S2 * 2)
        {
            if ((K - now) % 2 == 0)
            {
                a = i;       // 기본값 세팅
                toggle = !toggle;
                // toggle = true 면 "배치 순서를 반전"하여
                // 실제로는 "흑칸 (i+1), 백칸 i" 로 쓰겠다는 의미
                break;
            }
        }
    }

    // --------------------------------------------------
    // 5) 실제 격자에 동전 배치
    //    - i행 j열을 순회하며, toggle 플래그를 이용해
    //      번갈아가며 a+1, a (그리고 remainder 남아있으면 +2)
    //    - 한 행이 끝날 때, 열이 짝수개라면 토글 상태를
    //      다시 반전해 줘서 체스판 모양이 유지되도록 함
    // --------------------------------------------------
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= N; j++)
        {
            toggle = !toggle; // 칸 이동마다 색이 바뀐다고 가정

            if (toggle)
            {
                // '흰색'처럼 취급되는 칸에 (a+1) 기본 배치
                A[i][j] = a + 1;
            }
            else
            {
                // '검정색'처럼 취급되는 칸에 a 기본 배치
                A[i][j] = a;

                // remainder(남은 동전)이 있다면, 2개씩 추가
                if (remainder > 0)
                {
                    A[i][j] += 2;
                    remainder -= 2;
                }
            }
        }
        // 각 행을 마치고 나서, 열 개수가 짝수이면
        // toggle 상태를 다시 뒤집어서
        // 다음 행 시작 칸이 이전 행 시작 칸과
        // "다른 색"으로 인식되도록 함
        if (N % 2 == 0) 
        {
            toggle = !toggle;
        }
    }

    // --------------------------------------------------
    // 6) 최종적으로 배치된 동전 개수 확인
    //    만약 K가 아니라면 -1
    // --------------------------------------------------
    long long checkSum = 0;

    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= N; j++)
        {
            checkSum += A[i][j];
        }
    }
    if (checkSum != K)
    {
        cout << -1 << "\n";
        return 0;
    }

    // --------------------------------------------------
    // 7) 배치 결과 출력
    //    N행에 걸쳐, 각 행마다 N개의 정수를 공백으로 구분
    // --------------------------------------------------
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= N; j++)
        {
            cout << A[i][j];

            if (j < N)
            {
                cout << ' ';
            }
        }

        cout << '\n';
    }

    return 0;
}
